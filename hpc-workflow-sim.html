<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>HPC Workflow Simulator with Interactive Tooltips</title>
  <style>
    body { margin:0; padding:20px; background:#1e1e2f; color:#fafafa; font-family:Arial,sans-serif; }
    h1 { text-align:center; }
    #description { max-width:900px; margin:0 auto 20px; }
    #controls { max-width:900px; margin:0 auto 20px; }
    #simulator { display:block; margin:0 auto; background:#2e2e44; border-radius:12px; box-shadow:0 4px 20px rgba(0,0,0,0.5); }
    #jobList { max-width:900px; margin:20px auto; list-style:none; padding:0; }
    #jobList li { background:#344263; margin:4px 0; padding:6px 10px; border-radius:4px; }
    #tooltip {
      position:absolute; background:rgba(0,0,0,0.8); color:#fff; padding:8px; border-radius:4px;
      pointer-events:none; font-size:12px; display:none; max-width:200px; z-index:10;
    }
    .sparkline { width:180px; height:40px; background:#1e1e2f; display:block; margin-top:4px; }
  </style>
</head>
<body>
  <h1>HPC Workflow Simulator</h1>
  <div id="description">
    <p>This simulator visualizes job flow in a Slurm-based HPC cluster. Hover over nodes to see live stats with a smoother, slower sparkline.</p>
  </div>
  <div id="controls">
    <label for="coresInput">Cores (max 640):</label>
    <input type="number" id="coresInput" min="1" max="640" value="64" />
    <button id="startBtn">Submit Job</button>
  </div>
  <canvas id="simulator" width="900" height="600"></canvas>
  <ul id="jobList"></ul>
  <div id="tooltip"></div>

  <script>
    const canvas = document.getElementById('simulator');
    const ctx = canvas.getContext('2d');
    const startBtn = document.getElementById('startBtn');
    const coresInput = document.getElementById('coresInput');
    const jobListEl = document.getElementById('jobList');
    const tooltip = document.getElementById('tooltip');

    // --- Cluster Topology ---
    let nodes = [], connections = [];
    const utilHistory = [];      // per-node utilization history
    let lastSample = 0;          // timestamp for sparkline sampling (ms)

    function setupNodes() {
      nodes = [];
      nodes.push({id:'Laptop', x:100, y:300});
      nodes.push({id:'Login Node', x:250, y:300});
      nodes.push({id:'Head Node', x:400, y:300});
      const rack1X = 650, rack2X = 750, ys = [100,200,300,400,500];
      for(let i=0;i<5;i++) nodes.push({id:`Compute ${i+1}`, x:rack1X,y:ys[i],freeCores:64});
      for(let i=0;i<5;i++) nodes.push({id:`Compute ${i+6}`, x:rack2X,y:ys[i],freeCores:64});
      nodes.push({id:'GPFS', x:400, y:500});
      connections = [];
      [[0,1],[1,2]].forEach(p=>connections.push(p));
      for(let i=3;i<13;i++) connections.push([2,i],[i,13]);
      connections.push([1,13],[2,13]);
      utilHistory.length = 0; nodes.forEach(()=>utilHistory.push([]));
    }
    setupNodes();

    // --- Job & Network State ---
    let jobs = [], packets = [];
    let nextJobId = 1;
    const durations = {submit:1000,schedule:1000,compute:8000,return:1000};
    const totalDur = Object.values(durations).reduce((a,b)=>a+b* (b===durations.return?2:1));

    function addJob(cores){
      if(jobs.length>=5) return;
      let remain=cores, alloc=[];
      for(let i=3;i<13&&remain>0;i++){
        const avail=nodes[i].freeCores;
        if(avail>0){const use=Math.min(avail,remain);nodes[i].freeCores-=use;alloc.push({nodeIndex:i,cores:use});remain-=use;}
      }
      jobs.push({id:nextJobId++,cores,alloc,start:performance.now(),stage:-1});
      renderJobList();
    }
    function renderJobList(){jobListEl.innerHTML='';jobs.forEach(j=>{const li=document.createElement('li');li.textContent=`Job ${j.id}: ${j.cores} cores`;jobListEl.append(li);});}

    function spawnPackets(job,st){
      const now=performance.now();
      const push=(f,t,d)=>packets.push({from:f,to:t,start:now,duration:d});
      if(st===0) push(0,1,durations.submit);
      else if(st===1){[[1,2],[1,13],[2,13]].forEach(([f,t])=>push(f,t,durations.schedule));}
      else if(st===2){job.alloc.forEach(a=>{push(2,a.nodeIndex,durations.compute);push(a.nodeIndex,13,durations.compute/2);});[[1,13],[2,13]].forEach(([f,t])=>push(f,t,durations.compute));}
      else if(st===3){[[2,1],[1,13],[2,13]].forEach(([f,t])=>push(f,t,durations.return));}
      else if(st===4) push(1,0,durations.return);
    }

    // --- Tooltip & Sparkline ---
    canvas.addEventListener('mousemove',e=>{
      const rect=canvas.getBoundingClientRect(); const mx=e.clientX-rect.left, my=e.clientY-rect.top;
      let idx=-1; nodes.forEach((n,i)=>{if(Math.hypot(mx-n.x,my-n.y)<40) idx=i;});
      if(idx>=0){const n=nodes[idx]; const used=(idx>=3&&idx<13)?64-n.freeCores:null; const pkt=packets.filter(p=>p.from===idx||p.to===idx).length;
        tooltip.style.left=e.pageX+10+'px'; tooltip.style.top=e.pageY+10+'px';
        tooltip.innerHTML=`<strong>${n.id}</strong><br>`+(used!==null?`Cores: ${used}/64<br>Util: ${utilHistory[idx].slice(-1)[0]?.toFixed(1)}%<br>`:'')+`Packets: ${pkt}<br><canvas id='spark${idx}' class='sparkline'></canvas>`;
        tooltip.style.display='block'; setTimeout(()=>drawSpark(idx),0);
      } else tooltip.style.display='none';
    });
    function drawSpark(i){const c=document.getElementById('spark'+i); if(!c) return; c.width=180;c.height=40; const sctx=c.getContext('2d'); sctx.clearRect(0,0,180,40); const h=utilHistory[i]; if(h.length<2) return; sctx.beginPath(); sctx.strokeStyle='#00e5ff'; h.forEach((v,idx)=>{const x=(idx/(h.length-1))*180; const y=40-(v/100)*36; idx===0?sctx.moveTo(x,y):sctx.lineTo(x,y);}); sctx.stroke();}

    // --- Animation Loop ---
    function animate(){
      const now=performance.now(); ctx.clearRect(0,0,canvas.width,canvas.height);
      ctx.strokeStyle='#fff';ctx.lineWidth=2;connections.forEach(([a,b])=>{ctx.beginPath();ctx.moveTo(nodes[a].x,nodes[a].y);ctx.lineTo(nodes[b].x,nodes[b].y);ctx.stroke();});
      // usage calc
      const usages=Array(nodes.length).fill(0); let total=0; for(let i=3;i<13;i++){const u=64-nodes[i].freeCores;usages[i]=(u/64)*100;total+=u;} usages[13]=(total/640)*100; usages[1]=usages[2]=usages[13];
      // sample every 500ms
      if(now-lastSample>500){nodes.forEach((_,i)=>{utilHistory[i].push(usages[i]); if(utilHistory[i].length>180) utilHistory[i].shift();}); lastSample=now;}
      const active=Array(nodes.length).fill(false);
      jobs=jobs.filter(job=>{
        const el=now-job.start; let st=0;
        if(el<durations.submit) st=0; else if(el<durations.submit+durations.schedule) st=1; else if(el<durations.submit+durations.schedule+durations.compute) st=2; else if(el<totalDur-durations.return) st=3; else if(el<totalDur) st=4; else{job.alloc.forEach(a=>nodes[a.nodeIndex].freeCores+=a.cores);return false;}
        if(st!==job.stage){spawnPackets(job,st);job.stage=st;}
        if([0].includes(st)) active[0]=active[1]=active[13]=true; if(st===1) active[1]=active[2]=active[13]=true; if(st===2){job.alloc.forEach(a=>active[a.nodeIndex]=true); active[13]=true;} if(st>=3) active[2]=active[1]=active[13]=true;
        ctx.fillStyle='#ffc107';
        if(st===2) job.alloc.forEach(a=>{ctx.beginPath();ctx.arc(nodes[a.nodeIndex].x,nodes[a.nodeIndex].y,10,0,2*Math.PI);ctx.fill();});
        else{const path=[[0,1, durations.submit],[1,2,durations.schedule],[2,1,durations.return],[1,0,durations.return]]; const map={0:0,1:1,3:2,4:3}; if(map[st]!==undefined){const [f,t,d]=path[map[st]]; const tprog=(el- (st===0?0: st===1?durations.submit: st===3?durations.submit+durations.schedule+durations.compute:durations.submit+durations.schedule+durations.compute+durations.return) )/d; const x=nodes[f].x+(nodes[t].x-nodes[f].x)*tprog; const y=nodes[f].y+(nodes[t].y-nodes[f].y)*tprog; ctx.beginPath();ctx.arc(x,y,10,0,2*Math.PI);ctx.fill();}}
        return true;
      }); renderJobList();
      // packets
      packets=packets.filter(p=>{const t=(now-p.start)/p.duration; if(t<0) return true; if(t>1) return false; const x=nodes[p.from].x+(nodes[p.to].x-nodes[p.from].x)*t; const y=nodes[p.from].y+(nodes[p.to].y-nodes[p.from].y)*t; ctx.fillStyle='#00e5ff'; ctx.beginPath(); ctx.arc(x,y,6,0,2*Math.PI); ctx.fill(); return true;});
      // draw nodes
      nodes.forEach((n,i)=>{const pulse=active[i]?5*Math.sin(now/200):0, r=40+(active[i]?pulse:0); ctx.fillStyle=active[i]?'#ffd54f':'#4e8cff'; ctx.beginPath(); ctx.arc(n.x,n.y,r,0,2*Math.PI); ctx.fill(); ctx.fillStyle='#fff'; ctx.font='14px sans-serif'; ctx.textAlign='center'; ctx.fillText(n.id,n.x,n.y+5); if(active[i]&&(i>=3||i===1||i===2||i===13)){const pct=usages[i]; const bw=60,bh=6,bx=n.x-bw/2,by=n.y+45; ctx.strokeStyle='#fff'; ctx.strokeRect(bx,by,bw,bh); ctx.fillStyle='#ffcc4e'; ctx.fillRect(bx,by,bw*(pct/100),bh);} });
      requestAnimationFrame(animate);
    }

    startBtn.addEventListener('click',()=>addJob(parseInt(coresInput.value,10)));
    animate();
  </script>
</body>
</html>
