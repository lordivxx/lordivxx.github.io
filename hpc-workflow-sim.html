<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>HPC Workflow Simulator with Queue & 20‑Job Concurrency</title>
  <style>
    body{margin:0;padding:20px;background:#1e1e2f;color:#fafafa;font-family:Arial,sans-serif}
    h1{text-align:center}
    #description,#controls,#jobList{max-width:900px;margin:0 auto 20px}
    #simulator{display:block;margin:0 auto;background:#2e2e44;border-radius:12px;box-shadow:0 4px 20px rgba(0,0,0,.5)}
    #jobList li{background:#344263;margin:4px 0;padding:6px 10px;border-radius:4px}
    #tooltip{position:absolute;background:rgba(0,0,0,.8);color:#fff;padding:8px;border-radius:4px;font-size:12px;pointer-events:none;display:none;z-index:10;max-width:200px}
    .sparkline{width:180px;height:40px;background:#1e1e2f;display:block;margin-top:4px}
  </style>
</head>
<body>
  <h1>HPC Workflow Simulator</h1>
  <div id="description">
    <p>This interactive demo shows how research workloads move through a university Slurm cluster:</p>
    <ul>
      <li><strong>Topology flow</strong>: <em>Laptop → Login Node → Head Scheduler → 10 Compute Nodes (64 cores each) → GPFS Storage</em>.</li>
      <li><strong>Submit jobs</strong> using the form below. Specify any core count (1‑640). Up to 20 jobs can run at once; additional jobs wait in the queue until resources free up.</li>
      <li><strong>Visual cues</strong>:
        <ul>
          <li>Gold bubbles = job payloads.</li>
          <li>Cyan packets = network traffic on each link.</li>
          <li>Glow &amp; bars = node activity and real‑time utilisation.</li>
        </ul>
      </li>
      <li><strong>Hover</strong> over any node for a tooltip with free/used cores, live packet count, and a sparkline of utilisation history.</li>
    </ul>
    <p>Try submitting jobs of different sizes and watch how the scheduler allocates cores, queues excess jobs, and releases resources as work completes.</p>
  </div>
  <div id="controls">
    <label for="coresInput">Cores (max 640):</label>
    <input type="number" id="coresInput" min="1" max="640" value="64" />
    <button id="startBtn">Submit Job</button>
  </div>
  <canvas id="simulator" width="900" height="600"></canvas>
  <ul id="jobList"></ul>
  <div id="tooltip"></div>

  <script>
    const MAX_RUNNING = 20;
    const canvas = document.getElementById('simulator');
    const ctx = canvas.getContext('2d');
    const startBtn = document.getElementById('startBtn');
    const coresInput = document.getElementById('coresInput');
    const jobListEl = document.getElementById('jobList');
    const tooltip = document.getElementById('tooltip');

    /* ---------- Cluster topology ---------- */
    let nodes = [], connections = [];
    const utilHistory = [];
    let lastSample = 0;
    function initNodes(){
      nodes=[
        {id:'Laptop',x:100,y:300},
        {id:'Login Node',x:250,y:300},
        {id:'Head Node',x:400,y:300}
      ];
      const rackX=[650,750], ys=[100,200,300,400,500];
      for(let r=0;r<2;r++) for(let i=0;i<5;i++) nodes.push({id:`Compute ${r*5+i+1}`,x:rackX[r],y:ys[i],freeCores:64});
      nodes.push({id:'GPFS',x:400,y:500});
      connections=[[0,1],[1,2]];
      for(let i=3;i<13;i++) connections.push([2,i],[i,13]);
      connections.push([1,13],[2,13]);
      utilHistory.length=0;nodes.forEach(()=>utilHistory.push([]));
    }
    initNodes();

    /* ---------- Job & packet state ---------- */
    const durations={submit:1000,schedule:1000,compute:8000,return:1000};
    const totalDur=durations.submit+durations.schedule+durations.compute+durations.return*2;
    let nextJobId=1; let jobs=[]; let packets=[];

    function tryAllocate(job){
      let remain=job.cores; const alloc=[];
      for(let i=3;i<13&&remain>0;i++){
        const avail=nodes[i].freeCores;
        if(avail>0){const use=Math.min(avail,remain);nodes[i].freeCores-=use;alloc.push({nodeIndex:i,cores:use});remain-=use;}
      }
      if(remain===0){
        job.alloc=alloc; job.start=performance.now(); job.stage=-1; job.status='running';
      } else {
        // rollback allocation
        alloc.forEach(a=>nodes[a.nodeIndex].freeCores+=a.cores);
        job.status='queued';
      }
    }
    function submitJob(cores){
      const job={id:nextJobId++,cores,alloc:[],status:'new'};
      tryAllocate(job);
      if(job.status==='new') job.status='queued';
      jobs.push(job);
      renderJobList();
    }

    /* ---------- UI helpers ---------- */
    function renderJobList(){
      jobListEl.innerHTML='';
      const running=jobs.filter(j=>j.status==='running');
      const queued=jobs.filter(j=>j.status==='queued');
      running.forEach(j=>{const li=document.createElement('li');li.textContent=`▶ Job ${j.id}: ${j.cores} cores`;jobListEl.append(li);});
      queued.forEach(j=>{const li=document.createElement('li');li.textContent=`⏳ Job ${j.id}: ${j.cores} cores (queued)`;jobListEl.append(li);});
    }
    function pushPacket(f,t,d){packets.push({from:f,to:t,start:performance.now(),duration:d});}
    function spawnPackets(job,st){
      if(st===0) pushPacket(0,1,durations.submit);
      else if(st===1) [[1,2],[1,13],[2,13]].forEach(p=>pushPacket(...p,durations.schedule));
      else if(st===2){job.alloc.forEach(a=>{pushPacket(2,a.nodeIndex,durations.compute);pushPacket(a.nodeIndex,13,durations.compute/2);});[[1,13],[2,13]].forEach(p=>pushPacket(...p,durations.compute));}
      else if(st===3) [[2,1],[1,13],[2,13]].forEach(p=>pushPacket(...p,durations.return));
      else if(st===4) pushPacket(1,0,durations.return);
    }

    /* ---------- Tooltip ---------- */
    canvas.addEventListener('mousemove',e=>{
      const rect=canvas.getBoundingClientRect(); const mx=e.clientX-rect.left,my=e.clientY-rect.top;
      let idx=-1;nodes.forEach((n,i)=>{if(Math.hypot(mx-n.x,my-n.y)<40) idx=i;});
      if(idx>=0){const n=nodes[idx];const used=(idx>=3&&idx<13)?64-n.freeCores:null;const pkt=packets.filter(p=>p.from===idx||p.to===idx).length;
        tooltip.style.left=e.pageX+10+'px';tooltip.style.top=e.pageY+10+'px';
        tooltip.innerHTML=`<strong>${n.id}</strong><br>`+(used!==null?`Cores: ${used}/64<br>`:'')+`Packets: ${pkt}<br>`;
        tooltip.style.display='block';
      } else tooltip.style.display='none';
    });

    /* ---------- Animation ---------- */
    function animate(){
      const now=performance.now(); ctx.clearRect(0,0,canvas.width,canvas.height);
      ctx.strokeStyle='#fff';ctx.lineWidth=2;connections.forEach(([a,b])=>{ctx.beginPath();ctx.moveTo(nodes[a].x,nodes[a].y);ctx.lineTo(nodes[b].x,nodes[b].y);ctx.stroke();});
      // usage
      const usages=Array(nodes.length).fill(0);let tot=0;for(let i=3;i<13;i++){const used=64-nodes[i].freeCores;usages[i]=(used/64)*100;tot+=used;}usages[13]=(tot/640)*100;usages[1]=usages[2]=usages[13];
      if(now-lastSample>500){nodes.forEach((_,i)=>{utilHistory[i].push(usages[i]);if(utilHistory[i].length>180)utilHistory[i].shift();});lastSample=now;}
      // attempt to schedule queued jobs
      const runningCount=jobs.filter(j=>j.status==='running').length;
      jobs.filter(j=>j.status==='queued').forEach(j=>{if(j.status==='queued'&&runningCount<MAX_RUNNING) tryAllocate(j);});

      const active=Array(nodes.length).fill(false);
      jobs=jobs.filter(job=>{
        if(job.status!=='running') return true;
        const el=now-job.start; let st;
        if(el<durations.submit) st=0; else if(el<durations.submit+durations.schedule) st=1; else if(el<durations.submit+durations.schedule+durations.compute) st=2; else if(el<totalDur-durations.return) st=3; else if(el<totalDur) st=4; else {job.alloc.forEach(a=>nodes[a.nodeIndex].freeCores+=a.cores); job.status='done'; return false;}
        if(st!==job.stage){spawnPackets(job,st);job.stage=st;}
        if(st===0){active[0]=active[1]=active[13]=true;} else if(st===1){active[1]=active[2]=active[13]=true;} else if(st===2){job.alloc.forEach(a=>active[a.nodeIndex]=true);active[13]=true;} else if(st>=3){active[2]=active[1]=active[13]=true;}
        ctx.fillStyle='#ffc107'; if(st===2) job.alloc.forEach(a=>{ctx.beginPath();ctx.arc(nodes[a.nodeIndex].x,nodes[a.nodeIndex].y,10,0,2*Math.PI);ctx.fill();});
        else {
          const phase=[[0,1,durations.submit],[1,2,durations.schedule],[2,1,durations.return],[1,0,durations.return]];const m={0:0,1:1,3:2,4:3}; if(m[st]!==undefined){const [f,t,d]=phase[m[st]];const offset=st===0?0:st===1?durations.submit:st===3?durations.submit+durations.schedule+durations.compute:durations.submit+durations.schedule+durations.compute+durations.return;const prog=(el-offset)/d;const x=nodes[f].x+(nodes[t].x-nodes[f].x)*prog;const y=nodes[f].y+(nodes[t].y-nodes[f].y)*prog;ctx.beginPath();ctx.arc(x,y,10,0,2*Math.PI);ctx.fill();}
        }
        return true;
      });
      renderJobList();
      // packets
      packets=packets.filter(p=>{const t=(now-p.start)/p.duration;if(t<0)return true;if(t>1)return false;const x=nodes[p.from].x+(nodes[p.to].x-nodes[p.from].x)*t;const y=nodes[p.from].y+(nodes[p.to].y-nodes[p.from].y)*t;ctx.fillStyle='#00e5ff';ctx.beginPath();ctx.arc(x,y,6,0,2*Math.PI);ctx.fill();return true;});
      // nodes
      nodes.forEach((n,i)=>{const pulse=active[i]?5*Math.sin(now/200):0,r=40+(active[i]?pulse:0);ctx.fillStyle=active[i]?'#ffd54f':'#4e8cff';ctx.beginPath();ctx.arc(n.x,n.y,r,0,2*Math.PI);ctx.fill();ctx.fillStyle='#fff';ctx.font='14px sans-serif';ctx.textAlign='center';ctx.fillText(n.id,n.x,n.y+5);if(active[i]&&(i>=3||i===1||i===2||i===13)){const pct=usages[i];const bw=60,bh=6,bx=n.x-bw/2,by=n.y+45;ctx.strokeStyle='#fff';ctx.strokeRect(bx,by,bw,bh);ctx.fillStyle='#ffcc4e';ctx.fillRect(bx,by,bw*(pct/100),bh);}});
      requestAnimationFrame(animate);
    }

    startBtn.addEventListener('click',()=>submitJob(parseInt(coresInput.value,10)));
    animate();
  </script>
</body>
</html>
